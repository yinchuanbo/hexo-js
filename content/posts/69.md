---
title: "错误处理技巧"
date: 2023-10-07T22:03:53+08:00
---

## 拦截错误

### try/catch 语句

一般来说，JavaScript 中会以 try/catch 来拦截错误，且常常会搭配 finally 来减少重复的程序代码：

```js
try {
  // 可能出错的程序代码
} catch (error) {
  // 处理错误
} finally {
  // 此处必定执行
}
```

需要注意的是，在 **finally** 内使用 return 或 throw 会**覆写**掉 try/catch 内原本的操作：

```js
function foo() {
  try {
    throw new Error("Hello World!");
  } catch (error) {
    throw error;
  } finally {
    return "finally";
  }
}
console.log(foo()); // finally
```

```js
function bar() {
  try {
    return "try";
  } finally {
    throw new Error("finally");
  }
}
console.log(bar()); // Uncaught Error: finally
```

### 异步错误拦截

try/catch 只能拦截同步的错误，例如：

```js
try {
  Promise.reject("Promise rejection");
  setTimeout(() => {
    throw new Error("Timeout error");
  });
} catch (error) {
  console.error("err", error); // 没有拦截到错误
}
```

若要拦截错误，则需要加入额外的程序代码，例如：

```js
Promise.reject("Promise rejection")
  .then((data) => console.log("OK"))
  .catch((reason) => {
    console.log("Rejection handled.");
  })
  .finally(() => {
    console.log("Finally");
  });

setTimeout(() => {
  try {
    throw new Error("Timeout error");
  } catch (error) {
    console.log("Error handled.");
  }
});
```

此外，将 Callback 语句转化为 Promise 也是常见的用法，这么做的好处是可以把错误从 Callback 中取出来：

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    try {
      throw new Error("Timeout error!");
    } catch (error) {
      reject(error);
    }
  });
});
promise.catch((error) => {
  handleError(error); // 处理错误
});
```

[...138]
