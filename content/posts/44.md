---
title: "加载注意事项"
date: 2023-09-12T10:22:36+08:00
---

### 首屏加载

对于首屏上的内容就不应当进行延迟加载，而应该使用正常的加载方式。

此外，若将首屏视窗边界线作为延迟加载触发的阈值，其实并非最贱的性能考虑，更理想的做法是，在延迟加载的媒体资源到达首屏边界之前设置一个缓冲区，以便媒体资源在进入视窗之前就开始进行加载。

代码如下：

```js
const lazyImageObserver = new IntersectionObserver(
  (entries, onserver) => {
    // ....
  },
  {
    rootMargin: "0 0 256px 0",
  }
);
```

### 资源占位

当延迟加载的媒体资源未渲染出来之前，应当在页面中使用相同尺寸的占位图，如果不使用占位图，图像延迟显示出来后，尺寸更改可能会使页面布局出现移位。

这种现象不仅会对用户体验带来困惑，更严重的还会触发浏览器成本高昂的回流机制，进而增加系统资源开销，造成卡顿。

而用来占位的图像解决方案也有多种，十分简单的方式是使用一个与目标媒体资源长度相同的纯色占位符，或者之前使用的 Base64 图片，当然也可以采用 LQIP 或 SQIP 等方法。

### 内容加载失败

在进行延迟加载过程中，可能会因为某种原因造成媒体资源加载失败，进而导致错误的情况。

例如，图片资源可能采用以下方式进行规避：

```js
const newImage = new Image();
newImage.src = "photo.png";
newImage.onerror = (err) => {
  // 当发生故障时处理措施
  /*
    处理措施：
      01 可将使用的图片占位图替换为按钮，让用户单击以尝试重新加载所需的媒体资源。
      02 或者在占位符区域显示错误的提示信息。
  */
};
newImage.onload = () => {
  // 加载成功的回调
};
```

### 图像解码延迟

我们知道渐进式的 JPEG 会先呈现一个低像素的图像版本，随后会慢慢呈现出原图的样貌。这是因为图像从被浏览器请求获取，再到最终完整呈现在屏幕上，需要经历一个解码的过程。

图片的尺寸越大，所需的解码时间就越长。

如果在 js 中请求加载较大的图像文件，并把它直接放入 DOM 结构中，那么将有可能占用浏览器的主进程，进而导致解码期间用户界面出现短暂的无响应。

为了减少此类卡顿现象，可以采用 decode 方法进行异步图像解码后，再将其插入到 DOM 结构中。

**兼容处理**

```html
<button id="load-image">加载图像</button>
<div id="image-container"></div>
```

```js
document.addEventListener("DOMContentLoaded", () => {
  const loadButton = document.getElementById("load-image");
  const imageContainer = document.getElementById("image-container");
  const newImage = new Image();
  newImage.src = "https://xx.cdn/very-big-photo.jpg";
});
```

....
