---
title: "书写高性能的代码"
date: 2023-09-12T20:47:00+08:00
---

## 数据存取

### 数据存取方式

一般而言，Js 的数据存取有 4 种方式：

1. 直接字面量：字面量不存储在特定的位置，也不需要索引，仅仅代表自身，包括 `布尔值、数字、字符串、对象、数组、函数、null、undefined 及正则表达式`。

2. 变量：通过关键字 `const、let、var` 定义的数据存储单元。

3. 数组元素：存储在数组对象内部，通过数组下标数字进行索引。

4. 对象属性：存储在对象内部，通过对象的字符串名称进行索引。

其中数组元素和对象属性不仅可以是直接字面量的形式，还可以是其他数组对象或对象属性组成的更为复杂的数据结构。

从读取速度来看，直接字面量与变量是非常快的，相比之下数组元素和对象属性由于需要索引，其读取速度也会因其组成结构的复杂度越高而变的越慢。

### 作用域和作用域链

JavaScript 只有 **全局作用域** 和每个函数内部的 **局部作用域**。

**全局作用域** 就是无论此时执行的上下文是在函数内部还是函数外部，都能访问到存在于全局作用域中的变量或对象；

而定义存储在函数的 **局部作用域** 中的对象，只有在该函数内部执行上下文时才能都访问，而对函数外部不可见。

对于能够访问的数据，其在不同作用域中的查询也有 **先后顺序**。

这就涉及到 **作用域链** 的概念。

JavaScript 引擎会在页面加载后创建一个全局的作用域，然后每碰到一个要执行的函数，又会为其创建对应的作用域。

最终，不同的 **块级作用域** 和嵌套在内部的 **函数作用域**，会形成一个 **作用域堆栈**。

当前生效的作用域在堆栈的最顶端，由上往下就是当前执行上下文所能访问的作用域链。

**举一个简单的例子：**

```js
function plus(num) {
  return num + 1;
}
const ret = plus(6);
```

当这段代码刚开始执行时，函数 plus 的作用域中仅拥有一个指向全局对象的作用域，其中包括 `this、函数对象 plus 及常量 ret`，

而在执行到 plus 时，JavaScript 引擎会创建一个新的执行上下文和包含一些局部变量的活动对象。

执行过程会先对 num 标识符进行解析，即从作用域链的最顶层依次向下查找，直至找到 num 标识符。

<img src="/img/47/01.png" />

### 实战经验

1. 对局部变量的使用

**记住这一条建议：**

如果一个非局部变量在函数中的使用次数不止一次，那么最好使用局部变量进行存储。

```js
function process() {
  const target = document.getElementById("target");
  const imgs = document.getElementsByClassName("img");
  for (let i = 0; i < imgs.length; i++) {
    const img = imgs[i];
    //...
    target.appendChild(img);
  }
}
```

值得注意的是，document 属于全局作用域的对象，位于作用域链的最深处，在标识符解析过程中会被最后解析到。

由于它在此函数中使用了不止一次，所以可以考虑将其声明为一个局部变量，以提升其在作用域链中的查找顺序。

另外，计算类名为 img 的所有 DOM 节点数量的语句 imgs.length 执行了不止一遍。当查询所得的 DOM 节点列表存储到 imgs 中后，每次通过属性名或索引值读取 imgs 的属性时，DOM 都会重复执行一次对页面元素的查找，这个过程本身就会很缓慢。

**优化代码：**

```js
function process() {
  const doc = document;
  const target = doc.getElementById("target");
  const imgs = doc.getElementsByClassName("img");
  const len = imgs.length;
  for (let i = 0; i < len; i++) {
    const img = imgs[i];
    //...
    target.appendChild(img);
  }
}
```

2. 作用域链的增长

前面讲到可以通过将频繁使用的位于较深作用域链层级中的数据，声明为局部变量来提升标识符解析与访问的速度。

若能将全局变量提升到局部变量的访问高度，是否还能提升到比局部变量更高的位置呢？答案是 **可以的**。

在当前局部变量作用域前增加新的活动变量作用域，但这种增长了作用域链的做法用多了会造成过犹不及的效果。

比如 with 语句，它能将函数外层的变量，提升到比当前函数局部变量还要高的作用域链访问级别上。

如下代码由于使用 with 的缘故，在语句中可直接访问 param 中的属性值，虽然方便但却降低了 show() 函数原本局部变量的访问速度，所以应尽量少用。

```js
const param = {
  name: "Tian",
  value: 619,
};
function show() {
  const cnt = 2;
  with (param) {
    console.log("name is ${name}");
  }
}
```

另一个例子，就是经常用来进行异常捕获的 try-catch 语句，catch 代码块被用来处理捕获到的异常，

但其中包含错误信息 error 的作用域高于当前局部变量所在的代码块，

所以，建议不要在 catch 中处理过多复杂的业务逻辑，这样会降低数据的访问速度。

3. 警惕闭包的使用

闭包的特性是函数能够访问局部变量之外的数据，例如下面的代码：

```js
function mkFunc() {
  const name = "Tian";
  return function showName() {
    console.log(name);
  };
}
const mkFunc = mkFunc();
mkFunc();
```

showName() 函数就是一个闭包，它在 mkFunc() 函数被执行时被创建，并能访问 mkFunc() 函数的局部变量 name，

为此便需要创建一个独立于 mkFunc() 函数的作用域链

<img src="/img/47/02.png" />

一般的函数执行完成后，其中局部变量所占用的空间会被释放，但闭包的这种特性会**延长**父函数中局部变量的**生命周期**。

这也就意味着使用闭包可能会带来**更大**的内存开销及内存可能泄漏的影响。

## 流程控制

### 条件判断

1. **if-else** 和 **switch**

```js
if (value === 0) {
  //...
} else if (value === 1) {
  //...
} else if (value === 2) {
  //...
} else if (value >= 3 && value < 8) {
  //...
} else {
  //...
}
```

当变量的取值全部为离散取值时，便可将 **if-else** 的判断形式改为 **switch**

```js
switch (value) {
  case 0:
    //...
    break;
  case 1:
  case 2:
    //...
    break;
  case 3:
    //...
    break;
  default:
    //...
    break;
}
```

如果只有一两个条件的判断，通常 **if-else** 处理条件的时间会比 **switch** 更快，当判断条件多到两个以上时，因为在大多数时候，**switch** 处理单个条件的时间比 **if-else** 更快，所以 **switch** 更加适合。

2. **if-else** 的优化

- **第一种优化方式：** 开发者可以预估条件被匹配到的频率，按照频率的降序来排列 if-else 语句，可以让匹配频率高的条件更快执行，从而在整体上降低程序花费在条件判断上的时间。

```js
if (value === 8) {
  // 匹配到 8 的概率最高
} else if (value === 7) {
  // 匹配到 7 的概率仅次于 8
} else if (value === 6) {
  // 匹配到 6 的概率最低
} else {
  // ...
}
```

- **第二种优化方式：** 利用二分法的思路，如果并不能预先估计出各种条件在多次执行时被匹配到的频率，可以用二分法取值范围来降低匹配条件的执行次数。

```js
if (value < 4) {
  if (value < 2) {
    // 值在小于 2 时的情况，也可以继续二分
  } else {
    // 值在 2 或 3 之间
  }
} else {
  if (value < 6) {
    // 值在 4 或 5 之间
  } else {
    // 值在 6 到上界之间取值
  }
}
```

3. 数组索引和对象属性

```js
// 条件映射数组
const valueArray = [value0, value1, value2, value3, value4];
valueArray[value];
```

同样基于对象属性的映射方式，也能实现类似的条件查找行为，

```js
// 基于对象的属性映射
const valueMap = {
  condition0: () => {
    //...
  },
  condition1: () => {
    //...
  },
  condition2: () => {
    //...
  },
};
valueMap[value];
```

当匹配条件的数量较小时，并不适合使用这种基于数组或对象的查找方式，因为查找数组或映射对象属性值往往比执行少量的条件判断语句要慢，

只有当取值范围变得非常大时，这种查找方式的性能优势才会凸显出来。

4. 策略模式

【...】